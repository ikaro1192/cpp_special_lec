#スコープと関数

この章ではある程度の規模のプログラムを扱う上で必須となってくる関数およびその周辺の概念について学ぶ。

###この章でまなぶこと

- ブロックスコープの概念
- 関数
- プロトタイプ宣言
- 関数のオーバーロード

###この章の目標

- 関数を定義し使うことができる

##変数とブロックスコープ
変数にはスコープ(変数が生きている範囲)がある。スコープ内で変数の宣言が見つかるとそこで変数は作られ、 そしてスコープから抜けると変数は解体される。(変数の寿命)
では具体的にスコープの範囲はどこなのだろうか?
ここでは一番基本的なブロックスコープについて解説する。
それは非常に単純だ。
ブロック「つまり{}」で囲まれた範囲がスコープとなる
 以下のサンプルが必要なことをすべて示している。 

    #include<iostream>

     int main(){

         int hoge=2;
         int foo=4;
         std::cout << hoge << std::endl;
         std::cout << foo << std::endl;

         //forなどがないが立派なブロック
         {
             int hoge=4;
             int bar=2;

             foo=3;
             std::cout << hoge << std::endl;
             std::cout << foo << std::endl;
         }

         //bar=1;//コメントを外すとエラー
         std::cout << hoge << std::endl;
         std::cout << foo << std::endl;

         return 0;
     }

まず、hogeのようにスコープ内のスコープに同じ変数がある場合内側の変数が優先(逆に外側のスコープの変数が隠蔽さ)される。
当然、スコープを抜けると外側のスコープになるので元に戻る。
また、fooのように今のスコープに 変数が宣言されていない場合一つ外側のスコープの変数にアクセスされることになる。
しかし、barのように外側のスコープは内側のスコープにアクセスできない。
したがって当然if文やfor文に続くブロック内で定義した変数も外のスコープからは見えないので注意してほしい。
この性質を利用して{}で囲み変数名の衝突をさけるテクニックがある。これは次に説明する関数の 話にもつながっていく。

##関数
以上でプログラミングの基本はすべて終了した。(チューリング完全になっている)
ではもう学ぶことはないのだろうか?
残りは極論すればいかにうまく名前をつけるか(あるいは引きはがすか)ということである。
なぜ名前付けが重要なのだろうか？それはプログラミング言語とは何か?という問いを考えてみればわかる。
コンピュータ内部ではすべて0と1で扱われる。これでは扱いづらいのでそれに名前を付けて扱いやすくしたのがプログラミング言語だ。
また前回までで意味のある変数名を付けることでプログラムがわかりやすくなるということを話した。
このようにできるだけプログラムに名前を付けることができればよりわかりやすいプログラムにすることができると予想できる。
また、名前を付ければ理解しやすくなり人に伝えやすくなるのだ。
というわけで次は処理に名前をつけることを学ぶ。
初めは難しく感じ、使い方がつかめないかもしれないが積極的に使っていくことでそのうちわかってくるだろう
例えば0からnまでの和を求め出力するプログラムを考えよう。流れは以下のようになっている。

1. 入力
2. 和を求める
3. 出力

しかしコード上にはコメントでしか和を求めるということを明示することが今までのところできない。
この和を求めるという**操作に名前をつける文法が関数の定義**という形で用意されている。たとえばコードは以下のようになる。 

    #include<iostream>

    //0からEndNumberまでの和を求める関数
    int sum(int EndNumber){

        //計算結果を入れる変数
        int result = 0;

        for(int i=0; i<=EndNumber; ++i){
            result+=i;
        }

        //returnで結果を返す
        return result;
    }

    int main(){

        std::cout << "nの値を入力してください。"<< std::endl;
        int input;
        std::cin >> input;
        const int n = input;

        //関数の実行結果をSumResultに入れる
        const int SumResult = sum(n);

        //出力
        std::cout << "0からnまでの和は " << SumResult << "です" << std::endl;

    }

さて関数は「int sum(int EndNumber)」という形で定義されている。
コメントを見ればわかるようにこれは「0からEndNumberまでの和を求める」関数だ。
ここでいくつか用語を定義しておこう。
関数に渡す部分は**引数(パラメータ)**、関数が返した結果を**返り値(戻り値)**という。
つまり一般に関数の定義は

     返り値の型 関数名(引数1,引数2,...){ //～処理～ return (返す値); }
     
というものになる。
たとえば今回は返り値の型がint,引数が一つでintであるsumという関数ということになる。
forループの中身はただ足しているだけなので説明は要らないだろう。
そして最後のreturnだがこれは結果を返している。
ここまでの話で実は今までも関数を定義していたことに気づいた人がいるだろう。
そう。実はmainは関数だったのだ。
ただしmain関数は特殊でプログラムで一番最初に呼ばれる関数ということになっている。
また、返り値はどこに返されるのかというと一般にOSに返す。
さて定義した関数を呼び出しているのは 

    const int SumResult = sum(n); 

という部分だ。
sumという関数が実行されその結果がSumResultに代入される。
この時にnを渡している。
この渡すもののことを先ほど定義したように引数(あるいはパラメータ)と呼ぶ
なお、定義側の引数(EndNumber)を仮引数、使う側で渡している引数(n)を実引数と呼ぶ。
ちなみにこのEndNumberとnはsum関数が呼び出されたときにEndNumberにnの値が代入されるので、
値が同じになるがその後はまったく別のものとして扱われるので、同じnという名前にしても問題ない。
また今回は変数に入れているがsumは数値を返しているだけなので、
当然直接 

    std::cout << "0からnまでの和は " << sum(n) << "です" << std::endl;

のように表示することもできる。
さて今まで書いてきたmain関数には引数がない(実はmain関数には引数があるバージョンも存在する)もちろんこのように引数がない関数を定義することも可能だ。
次はさらに関数化していこう。おそらく最終的には(これはやりすぎだが)以下のサンプルのようになる。
(さっきのをコピペして関数の中に入れるだけでよい)  

    #include<iostream>
     
    //入力を受ける関数(引数なし)
    int input(){
        std::cout << "nの値を入力してください。"<< std::endl;
        int input;
        std::cin >> input;
        return input;
        }
     
    //EndNumberまでの和を求める関数
    int sum(int EndNumber){
        //計算結果を入れる変数
        int result=0;
         
        for(int i=0;i<=EndNumber;++i){
            result+=i;
        }
     
        //returnで結果を返す
        return result;
    }
     
    //出力する関数
    void output(int SumResult){
        std::cout << "0からnまでの和は " << SumResult << "です" << std::endl;
        return;//何も返さない
    }
     
    int main(){
     
        const int InputData = input();
        const int SumResult=sum(InputData);
        output(SumResult);
     
    }

ここで見てほしいのは、引数、返り値をもつ関数(sum),返り値のみを持つ関数(input),引数のみを 持つ関数(output)の三種類があるということだ。
output関数のvoidというのはどんな型でもない型、つまり返り値なしということをあらわしている。
したがってreturnではなにも返していない。

ここまでするとひとつのことが導かれ、またひとつの問題が出てくる。
導かれることというのは定義した関数はどこで呼んでもいい、
つまり今までは処理をコピペしていたのがコピペせずとも必要なところで定義した関数を呼べばいい(たとえば数字を入力させたいときは input関数を呼ぶ)
そうすれば引数さえ正しく指定すればバグがなくその部分利用することが出来る(もちろん関数が正しく実装されていれば)
非常に見通しがよくなった気がしないだろうか?
また、これは処理を探してそれがいちいち内部で何をしているのか理解しなくてもよいということである。
これで引数と結果さえ知っていればいつでもどこでもそして誰でも使うことが できるようになった。
このように関数化するとプロプラムがわかりやすくそして再利用性が高まる。
ここで注意してほしいのは再利用性を高めようとしてプログラミングをしてたわけではなく、
処理を書いてみてどうやらその処理で名前がつけられそうだという発想で関数を作ったということだ。
もちろん慣れてくれば設計段階で関数を考えることができるようになる。
しかし、最初のうちはそれが難しいだろう。
そこで常に今やっている処理に名前が付けられないか考ていくというのが妥当だろう。
あるいは共通している部分を抜き出す(抽象化する)というのも関数化するコツだ。
また、あまりに関数が多くなりすぎるのもやりすぎだ(ここではoutputなど)。
どの程度の粒度で関数化していくか?というのは慣れしかない。
(目安としてはその処理のコードがパッと見でわからないようだったら関数化する)
といっても関数化してもプログラムがバグを生むわけでもないので恐れずに積極的に使っていってほしい。

#プロトタイプ宣言
さて、問題というのはプログラム上の欠陥というわけではないのだが、
多くの関数を定義しているとmain関数にたどり着くまでにたくさんスクロールしなくてはいけないということだ。
今は小さいプログラムだからいいが、200行規模以上の関数が5つあるだけですでに1000行になってしまう。
main関数を見つけるまでに1000行スクロールしなくてはいけない。
これはいやだろう。
もちろんこれを解決する文法はC++に備わっている。
まずは簡単な方からしよう。
重要な点は関数を使う人は引数と返り値の意味さえ知っていればいいということだ。
つまり、使う側にとって内部処理などどうでもいいのだ。 

    #include<iostream>


    //==============================プロトタイプ宣言===============================
    //入力を受ける関数
    int input();

    //EndNumberまでの和を求める関数
    int sum(int EndNumber);

    //SumResultを出力する関数
    void output(int SumResult);

    //===================================main関数===================================
    int main(){

        const int InputData = input();
        const int SumResult=sum(InputData);
        output(SumResult);

    }

    //=====================================実装=====================================
    int input(){
        std::cout << "nの値を入力してください。"<< std::endl;
        int input;
        std::cin >> input;
        return input;
    }

    int sum(int EndNumber){

        //計算結果を入れる変数
        int result=0;

        for(int i=0;i<=EndNumber;++i){
            result+=i;
        }

        //returnで結果を返す
        return result;
    }

    //出力する関数
    void output(int SumResult){
        std::cout << "0からnまでの和は " << SumResult << "です" << std::endl;
        return;//何も返さない
    }

だいぶmainの前がすっきりしただろう。
プロトタイプ宣言というのはこんな関数をプログラム内で使いますよという宣言でそこでの実装は必要ない。
実装は全部main関数の後ろでしている。

##関数のオーバーロード(多重定義) 
名前はいかついが、内容はそこまで複雑ではない。

    #include<iostream>

    //aとbの和を返す関数
    int add(int a, int b);

    //===================================main関数===================================
    int main(){

        std::cout << add(3,5)<<std::endl;
        std::cout << add(3.3,5.5)<<std::endl;
    }

    //=====================================実装=====================================

    int add(int a, int b){
        return a+b;
    }

当然add関数はint型を受け取りint型で返す関数なので後者は小数で答えが返ってこない。
そこで以下のようにdoubleバージョンの関数を定義してあげればよい。これだけだ。
オーバーロードとは結局「関数名は一緒で別の引数の関数を作れますよ」ということなので、 もちろん同じ名前の2つの引数の関数と3つの引数の関数を定義することも可能だ。 

    #include<iostream>


    //aとbの和を返す関数(int版)
    int add(int a, int b);
    //double版
    double add(double a, double b);

    //===================================main関数===================================
    int main(){

        std::cout << add(3,5)<<std::endl;
        std::cout << add(3.3,5.5)<<std::endl;
    }

    //=====================================実装=====================================

    int add(int a, int b){
        return a+b;
    }

    double add(double a, double b){
        return a+b;
    }

注意して欲しいのが、オーバーロードができるのは引数がことなる関数だけで、
返り値がことなる関数は定義できない。したがって以下はコンパイルエラーとなる。


##演習問題

- 前回のサンプルコードでwhileの中にconst変数があった。一見複数回初期化できているように見える。これをスコープの観点から説明せよ。
- 二乗を返す関数をint型、double型それぞれ実装せよ。
- 以下のプログラム(コード1)を関数を用いて書き直せ
    - 作成した関数をプロトタイプ宣言を用いて書きなおせ

コード1

    #include<iostream>
    #include<string>

    int main(){

        while(1){
            std::cout<<"0:すごいHaskell楽しく学ぼう!"<<std::endl;
            std::cout<<"1:EffectiveC++"<<std::endl;
            std::cout<<"2:ModernC++Design"<<std::endl;

            std::cout<<"購入する本のIDを入力してください(-1で終了)"<<std::endl;

            int input;
            std::cin>>input;
            const int SelectedID=input;

            if (SelectedID==0){
                std::cout<<"本当に「すごいHaskell楽しく学ぼう!」を購入しますか?(y/n)"<<std::endl;
            }else if (SelectedID==1){
                std::cout<<"本当に「EffectiveC++」を購入しますか?(y/n)"<<std::endl;
            }else if (SelectedID==2){
                std::cout<<"本当に「ModernC++Design」を購入しますか?(y/n)"<<std::endl;
            }else if (SelectedID==-1){
                break;
            }else{
                std::cout<<"入力が不正です"<<std::endl;
                continue;//ループをやり直す命令
            }

            while(true){
                std::string input;
                std::cin>>input;
                const std::string SelectedCommand=input;

                if (SelectedCommand=="y"){
                    std::cout<<"ご購入ありがとうございます！"<<std::endl;
                    break;
                }else if (SelectedCommand=="n"){
                    std::cout<<"そうですか..."<<std::endl;
                    break;
                }else{
                    std::cout<<"入力が不正です。yかnを入力してください"<<std::endl;
                }

            }

        }


        return 0;
    }

