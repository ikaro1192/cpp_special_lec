#配列変数

この章では同じ型の変数を値をまとめて扱う方法である配列について学ぶ。

###この章でまなぶこと

- 配列変数

##復習

- 0〜99までの数字をするプログラムを作れ。 ただし2の倍数ならFizzを3の倍数ならBuzzを両方に当てはまっていればFizzBuzzを数字の代わりに出力すること。(FizzBuzz問題) 


##配列変数
たとえば、100人の点数を管理するソフトを考えよう。
このためには100人分の成績を入れるために100個の変数を用意する必要がある。
score_1, socore_2, score_3...と変数を宣言して確保していけばよいが、
たぶんそんなことは誰もしたくないだろう。
そこで一気に変数を確保して番号で管理できる配列(変数)というものが存在する。
とりあえず以下のサンプルを見てほしい。
5個分のint型配列を確保し、代入してそれを表示するサンプルだ。 

```
#include<iostream>
 
int main(){
     
    //5個分の配列変数を確保
    int array[5];
     
    //代入(0から始まり4までなことに注意!)
    array[0]=1;
    array[1]=7;
    array[2]=14;
    array[3]=0;
    array[4]=9;
    //array[5]=5;//これはダメ!!ゼッタイ！
 
    //配列はこのようにループと相性がいい
    for(int i=0;i<5;++i){
        std::cout << "array[" <<i << "]の値は"<< array[i] << "です" <<  std::endl;
    }
 
    return 0;
 
}
```

まず、

    int array[5];

の部分で
nt型のarrayという変数を5個分確保している。
ここでは確保しているだけなので代入はされていない。
そしてたとえば 

    array[0]=1;

のように、つまり一般的に

    array[index(添え字)]=値;

注意してほしいのはコメントに書いてあるように**添え字は0から始まって4までの5個**ということだ。
つまりint hoge[n]という配列は「0～(n-1)」までの範囲をとる。 (添え字が5の要素に代入するとどうなるかは各自試してほしい)
ここは間違えやすいので注意してほしい。
なんでこんな仕様になっているかということだが「#0は自然数」だから...ということではなくもっと根本的な理由による。
これについてはポインタの回に詳しく説明する。 ここまでの話だとたとえば 

    array2=値;

変わらないじゃないかと思うかもしれない。
本当に役に立つのはループの時などだ。 

    for(int i=0;i<5;++i){
            std::cout << array[i] << std::endl;
    }

というコードを見ればわかるように添え字にiを使うことによって無駄なコードを書かなくてすむ (iは0から4まで変化)。
このように配列変数は**forなどのループと非常に相性がいい。**
最後に注意しておかなくてはいけないのは**配列の要素数はコンパイル時に決定できる定数ではなくてはいけない**ということだ。
ようするに変数の値を配列の要素数にすることは出来ない。 
※なお、この配列の要素数がコンパイル時定数という制約はC++14でなくなり、動的配列も確保できるようになっている。

##演習問題

- 入力された10個の数値を入力された順序と逆に表示するプログラムを作成せよ。
- 5人分の点数をうけとり、点数を低い順に並び替えて表示せよ(ソート, 点数のみの表示で良い)
- ソートはよくでてくる操作である。どのようなアルゴリズムがあるか調べてみよ(安定なソートについても調べてみると理解が深まる)
